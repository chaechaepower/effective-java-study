# 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

[💠 상속을 자제하고 합성(Composition)을 이용하자](https://inpa.tistory.com/entry/OOP-💠-객체-지향의-상속-문제점과-합성Composition-이해하기)

> 상속을 고려한 설계와 문서화란 정확한 무얼 뜻하는가?
> 

메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.

⇒ **상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.**

# 상속

<aside>
💡 왜 상속을 고려해야 하는가?

</aside>

### 유지보수성: 상위 클래스의 변경이 하위 클래스에 미치는 영향

- 하위 클래스의 의존성:
    - 하위 클래스는 상위 클래스의 구현 세부 사항에 의존할 수 있다.
    - 상위 클래스의 변경이 하위 클래스의 동작에 영향을 미칠 수 있기 때문에, 상위 클래스를 변경할 때는 하위 클래스의 동작을 예측하고 테스트해야 한다.
- 호환성 보장:
    - 상위 클래스를 변경할 때, 해당 클래스를 상속하는 모든 하위 클래스와의 호환성을 유지해야 한다.
    - 고려하지 않으면 큰일난다.

### 확장성: 하위 클래스에서의 메서드 오버라이딩

- 확장 지침 제공
    - 상속을 고려해 설계하고 문서화하면 하위 클래스 작성자가 어떤 메서드를 오버라이드할 수 있고, 어떤 메서드는 오버라이드하면 안 되는지 명확히 알 수 있다.
    - 하위 클래스의 구현이 의도한 대로 동작하도록 한다.
- 확장 포인트 제공
    - 상속을 고려한 설계는 하위 클래스가 확장할 수 있는 명확한 포인트를 제공한다.
    - 이런 포인트는 문서화되어 있어야 하며, 하위 클래스 작성자가 이 확장 포인트를 이해하고 올바르게 사용할 수 있어야 한다.

### 안정성: 클래스의 불변성과 상태 유지

- 불변성 유지
    - 상속을 고려하지 않고 설계된 클래스는 하위 클래스에서 불변성을 깨뜨릴 수 있는 위험이 있다.
    - 예: 상위 클래스에서 final로 선언된 메서드가 하위 클래스에서 오버라이딩되면 불변성이 깨질 수 있다.
- 상태 일관성
    - 상속을 고려해 설계하면 상위 클래스와 하위 클래스의 상태가 일관성을 유지할 수 있도록 보장할 수 있다.
    - 하위 클래스에서 상위 클래스의 상태를 변경하면 예기치 않은 동작이 발생할 수 있기 때문에, 이러한 상황을 방지할 수 있다.

⇒ 위와 같은 이유로 상속을 고려해 설계하고 문서화하라

<aside>
💡 결론: 상속 그냥 쓰지마셈

</aside>

### 클래스를 final로 선언

- 클래스에 final 키워드를 붙이면 상속이 불가능하다.

```java
public final class UtilityClass {
} 
```

### 메서드를 final로 선언

- 클래스 자체는 상속이 되지만 특정 메서드를 오버라이딩하지 못하게 한다.

```java
public class BaseClass {
		public final void doNotOverride() {
		
		}
}
```

### 생성자를 private으로 선언

- 클래스를 상속할 수 없도록 생성자를 private으로 선언한다.

```java
public class UtilityClass {
		private UtilityClass() {
				// 인스턴스화 방지
		}
}
```

상속을 제대로 활용하기 위해서는 부모 클래스의 내부 구현에 대해 상세하게 알아야 하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아질 수 밖에 없다.

또한 상속 관계는 컴파일 타임에 결정되고 고정되기 때문에 코드를 실행하는 도중에 변경할 수 없다.

따라서 여러 기능을 조합해야 하는 설계에 상속을 이용하게 된다면 모든 조합별로 클래스를 하나하나 추가해 주어야 한다.

⇒ **클래스 폭발 문제**

---

# 합성

기존 클래스를 상속을 통한 확장을 하는 대신에, **필드로 클래스의 인스턴스를 참조**하게 만드는 설계

```java
class Car {
    Engine engine; // 필드로 Engine 클래스 변수를 갖는다(has)

    Car(Engine engine) {
        this.engine = engine; // 생성자 초기화 할때 클래스 필드의 값을 정하게 됨
    }

    void drive() {
        System.out.printf("%s엔진으로 드라이브~\n", engine.EngineType);
    }

    void breaks() {
        System.out.printf("%s엔진으로 브레이크~\n", engine.EngineType);
    }
}

class Engine {
    String EngineType; // 디젤, 가솔린, 전기

    Engine(String type) {
        EngineType = type;
    }
}
```

<aside>
💡 Java의 창시자인 제임스 고슬링(James Arthur Gosling)이 한 인터뷰에서 **"내가 자바를 만들면서 가장 후회하는 일은 상속을 만든 점이다"** 라고 말할 정도 이다.

조슈야 블로크의 Effective Java에서는 상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라는 조언을 한다.

따라서 추상화가 필요하면 인터페이스로 implements 하거나 객체 지향 설계를 할땐 합성(composition)을 이용하는 것이 추세이다.

</aside>

- 합성을 사용 해야하는 이유
    - 객체의 내부는 공개되지 않고 인터페이스를 통해 코드를 재사용하기 때문에, 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경하여 결합도를 낮출 수 있다.